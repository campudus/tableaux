package com.campudus.tableaux.helper

import com.campudus.tableaux.NotImplementedException
import com.campudus.tableaux.database.domain.Table
import com.campudus.tableaux.database.domain.TableType
import com.campudus.tableaux.database.domain.UnionTable
import com.campudus.tableaux.database.domain.UnionTableRow
import com.campudus.tableaux.database.model.TableauxModel.RowId
import com.campudus.tableaux.database.model.TableauxModel.TableId

object UnionTableHelper {

  val message = "Operation not implemented for table of type union"

  def notImplemented(table: Table) = {
    table.tableType match {
      case UnionTable => throw new NotImplementedException(message)
      case _ =>
    }
  }

  /**
    * Because the frontend and other API consumers cannot handle composite row IDs (tableId and rowId), we calculate a
    * unique row ID by adding a table-specific offset to the row ID. This is the easiest way to handle that problem
    * without changing the frontend and the API. We will encounter problems if we have more than 1,000,000 rows in a
    * single table, but that is highly unlikely today and it is possible to manually increase the offset if needed.
    *
    * @param tableId
    * @param rowId
    * @return
    *   compositeId
    */
  def calcRowId(tableId: TableId, rowId: RowId, rowOffset: Long): RowId =
    (tableId * rowOffset) + rowId

  /**
    * Extracts tableId and rowId from a generated composite id generated by UnionTableRow::calcRowId. Because we want to
    * keep implementation in the front end simple, we generate a unique rowId in the back end. In order to be able to
    * query a single row again, we have to break this ID down into tableId and rowId of the originTable.
    *
    * @param compositeId
    * @return
    *   (tableId, rowId)
    */
  def extractTableIdAndRowId(compositeId: Long, rowOffset: Long): (TableId, RowId) = {
    val tableId = (compositeId / rowOffset).toLong
    val rowId = (compositeId % rowOffset).toLong
    (tableId, rowId)
  }
}
